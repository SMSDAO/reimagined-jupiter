name: Self-Optimizing Workflow

on:
  pull_request:
    branches:
      - dev
      - develop
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to optimize'
        required: true
        type: number

permissions:
  contents: write
  pull-requests: write
  checks: write
  security-events: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  analyze-and-optimize:
    name: Analyze & Auto-Optimize Codebase
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref || github.ref }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: |
          npm ci
          cd webapp && npm ci
          
      - name: Install analysis tools
        run: |
          npm install -g eslint
          npm install --save-dev @typescript-eslint/eslint-plugin@latest
          npm install --save-dev eslint-plugin-unused-imports
          npm install --save-dev ts-prune
          npm install --save-dev depcheck
          
      # Stage 1: Code Analysis
      - name: Run comprehensive code analysis
        id: analysis
        run: |
          echo "## Code Analysis Report" > analysis-report.md
          echo "" >> analysis-report.md
          
          # ESLint analysis with auto-fixable issues
          echo "### ESLint Analysis" >> analysis-report.md
          npx eslint 'src/**/*.ts' 'api/**/*.ts' 'scripts/**/*.ts' --format json --output-file eslint-report.json || true
          
          # TypeScript unused exports detection
          echo "### Unused Exports Detection" >> analysis-report.md
          npx ts-prune --error --json > ts-prune-report.json || true
          
          # Unused dependencies check
          echo "### Dependency Analysis" >> analysis-report.md
          npx depcheck --json > depcheck-report.json || true
          
          # Webapp analysis
          cd webapp
          npx eslint . --format json --output-file ../eslint-webapp-report.json || true
          cd ..
          
          echo "analysis_complete=true" >> $GITHUB_OUTPUT
          
      # Stage 2: Auto-fix safe issues
      - name: Apply safe auto-fixes
        id: autofix
        run: |
          echo "## Auto-Fix Report" > autofix-report.md
          echo "" >> autofix-report.md
          
          # Count files before fixes
          FILES_BEFORE=$(git status --porcelain | wc -l)
          
          # ESLint auto-fix for backend
          echo "### Backend Fixes" >> autofix-report.md
          npx eslint 'src/**/*.ts' 'api/**/*.ts' 'scripts/**/*.ts' --fix --fix-type problem,suggestion,layout || true
          
          # ESLint auto-fix for webapp
          echo "### Webapp Fixes" >> autofix-report.md
          cd webapp
          npx eslint . --fix --fix-type problem,suggestion,layout || true
          cd ..
          
          # Prettier formatting (if configured)
          if [ -f ".prettierrc" ] || [ -f ".prettierrc.json" ]; then
            echo "### Code Formatting" >> autofix-report.md
            npx prettier --write 'src/**/*.ts' 'api/**/*.ts' 'scripts/**/*.ts' 'webapp/**/*.{ts,tsx}' || true
          fi
          
          FILES_AFTER=$(git status --porcelain | wc -l)
          FILES_MODIFIED=$((FILES_AFTER - FILES_BEFORE))
          
          echo "files_modified=$FILES_MODIFIED" >> $GITHUB_OUTPUT
          
          # Check if there are changes
          if [ -n "$(git status --porcelain)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
          
      # Stage 3: Remove dead code
      - name: Identify and remove dead code
        id: deadcode
        run: |
          echo "## Dead Code Analysis" > deadcode-report.md
          echo "" >> deadcode-report.md
          
          # Parse ts-prune results and identify truly unused exports
          if [ -f "ts-prune-report.json" ]; then
            echo "### Unused Exports Found" >> deadcode-report.md
            
            # Create a script to safely remove unused exports
            cat > remove-unused.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // Read ts-prune report
          let unusedExports = [];
          try {
            const report = fs.readFileSync('ts-prune-report.json', 'utf8');
            // Parse and filter safe-to-remove exports
            // Only remove if:
            // 1. Not in index files
            // 2. Not in test files
            // 3. Not marked as public API
            // 4. Not used in any way
            
            const lines = report.split('\n').filter(line => line.trim());
            for (const line of lines) {
              if (line.includes('used in module') === false && 
                  !line.includes('/index.ts') && 
                  !line.includes('.test.ts') &&
                  !line.includes('.spec.ts')) {
                unusedExports.push(line);
              }
            }
          } catch (e) {
            console.log('No unused exports found or error parsing report');
          }
          
          // Log what would be removed (for review, not actually removing yet)
          if (unusedExports.length > 0) {
            console.log(`Found ${unusedExports.length} potentially unused exports`);
            fs.writeFileSync('unused-exports.txt', unusedExports.join('\n'));
          }
          EOF
            
            node remove-unused.js
            
            if [ -f "unused-exports.txt" ]; then
              cat unused-exports.txt >> deadcode-report.md
              echo "found_unused=true" >> $GITHUB_OUTPUT
            else
              echo "No safe-to-remove unused code found" >> deadcode-report.md
              echo "found_unused=false" >> $GITHUB_OUTPUT
            fi
          fi
          
      # Stage 4: Test coverage analysis
      - name: Analyze test coverage
        id: coverage
        run: |
          echo "## Test Coverage Analysis" > coverage-report.md
          echo "" >> coverage-report.md
          
          # Run tests with coverage
          npm test -- --coverage --coverageReporters=json-summary || true
          
          # Parse coverage report
          if [ -f "coverage/coverage-summary.json" ]; then
            echo "### Coverage Summary" >> coverage-report.md
            node -e "
              const coverage = require('./coverage/coverage-summary.json');
              const total = coverage.total;
              console.log('| Metric | Percentage |');
              console.log('|--------|------------|');
              console.log('| Lines | ' + total.lines.pct + '% |');
              console.log('| Statements | ' + total.statements.pct + '% |');
              console.log('| Functions | ' + total.functions.pct + '% |');
              console.log('| Branches | ' + total.branches.pct + '% |');
              
              // Identify files with low coverage
              const files = Object.entries(coverage).filter(([k]) => k !== 'total');
              const lowCoverage = files.filter(([_, v]) => v.lines.pct < 80);
              
              if (lowCoverage.length > 0) {
                console.log('\n### Files Needing Tests (< 80% coverage)');
                lowCoverage.forEach(([file, data]) => {
                  console.log('- ' + file + ' (' + data.lines.pct + '%)');
                });
              }
            " >> coverage-report.md
          fi
          
          echo "coverage_analyzed=true" >> $GITHUB_OUTPUT
          
      # Stage 5: Security and quality analysis
      - name: Run security and quality checks
        id: security
        run: |
          echo "## Security & Quality Analysis" > security-report.md
          echo "" >> security-report.md
          
          # Check for common security issues
          echo "### Security Issues" >> security-report.md
          
          # Check for hardcoded secrets (basic patterns)
          echo "#### Potential Secret Detection" >> security-report.md
          git grep -n -i -E '(password|secret|api_key|private_key|token)\s*=\s*["\x27][^"\x27]{8,}' -- '*.ts' '*.js' || echo "No obvious hardcoded secrets found" >> security-report.md
          
          # Check for unsafe practices
          echo "#### Unsafe Code Patterns" >> security-report.md
          git grep -n -E '(eval\(|Function\(|innerHTML\s*=|dangerouslySetInnerHTML)' -- '*.ts' '*.tsx' '*.js' || echo "No obvious unsafe patterns found" >> security-report.md
          
          # npm audit
          echo "#### Dependency Vulnerabilities" >> security-report.md
          npm audit --json > npm-audit.json || true
          
          if [ -f "npm-audit.json" ]; then
            node -e "
              const audit = require('./npm-audit.json');
              const vulns = audit.metadata?.vulnerabilities || {};
              const total = Object.values(vulns).reduce((a, b) => a + b, 0);
              if (total > 0) {
                console.log('Found ' + total + ' vulnerabilities');
                console.log('- Critical: ' + (vulns.critical || 0));
                console.log('- High: ' + (vulns.high || 0));
                console.log('- Moderate: ' + (vulns.moderate || 0));
                console.log('- Low: ' + (vulns.low || 0));
              } else {
                console.log('No vulnerabilities found');
              }
            " >> security-report.md
          fi
          
      # Stage 6: CodeQL integration
      - name: Run CodeQL analysis
        uses: github/codeql-action/init@v3
        with:
          languages: javascript
          config-file: ./.github/codeql-config.yml
          
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:javascript"
          upload: false
          output: codeql-results
          
      # Stage 7: Generate comprehensive report
      - name: Generate optimization report
        id: report
        run: |
          cat > optimization-report.md << 'EOF'
          # ðŸ” Automated Code Optimization Report
          
          This report was automatically generated by the Self-Optimizing Workflow.
          
          ---
          
          EOF
          
          # Combine all reports
          cat analysis-report.md >> optimization-report.md || true
          echo "" >> optimization-report.md
          cat autofix-report.md >> optimization-report.md || true
          echo "" >> optimization-report.md
          cat deadcode-report.md >> optimization-report.md || true
          echo "" >> optimization-report.md
          cat coverage-report.md >> optimization-report.md || true
          echo "" >> optimization-report.md
          cat security-report.md >> optimization-report.md || true
          
          # Add recommendations
          cat >> optimization-report.md << 'EOF'
          
          ---
          
          ## ðŸ“‹ Automated Actions Taken
          
          EOF
          
          if [ "${{ steps.autofix.outputs.has_changes }}" = "true" ]; then
            echo "âœ… Applied safe auto-fixes to ${{ steps.autofix.outputs.files_modified }} files" >> optimization-report.md
          else
            echo "â„¹ï¸ No auto-fixable issues found" >> optimization-report.md
          fi
          
          cat >> optimization-report.md << 'EOF'
          
          ## âš ï¸ Manual Review Required
          
          The following items require manual review:
          
          EOF
          
          # Parse ESLint report for unfixable issues
          if [ -f "eslint-report.json" ]; then
            node -e "
              const report = require('./eslint-report.json');
              let unfixableCount = 0;
              let riskyPatterns = [];
              
              report.forEach(file => {
                file.messages.forEach(msg => {
                  if (!msg.fix) {
                    unfixableCount++;
                    if (msg.severity === 2) {
                      riskyPatterns.push({
                        file: file.filePath,
                        line: msg.line,
                        message: msg.message,
                        rule: msg.ruleId
                      });
                    }
                  }
                });
              });
              
              if (unfixableCount > 0) {
                console.log('### Unfixable ESLint Issues: ' + unfixableCount);
                console.log('');
                riskyPatterns.slice(0, 10).forEach(p => {
                  console.log('- **' + p.file + ':' + p.line + '** - ' + p.message + ' (' + p.rule + ')');
                });
                if (riskyPatterns.length > 10) {
                  console.log('- ... and ' + (riskyPatterns.length - 10) + ' more');
                }
              }
            " >> optimization-report.md || true
          fi
          
          # Add unused code section
          if [ "${{ steps.deadcode.outputs.found_unused }}" = "true" ]; then
            echo "" >> optimization-report.md
            echo "### Unused Code Detected" >> optimization-report.md
            echo "See dead code analysis section above for details." >> optimization-report.md
            echo "**Action Required**: Review and remove unused exports if safe." >> optimization-report.md
          fi
          
          cat >> optimization-report.md << 'EOF'
          
          ---
          
          ## ðŸŽ¯ Recommendations
          
          1. **Review Auto-Fixes**: All automatic fixes have been applied and are safe.
          2. **Address ESLint Issues**: Fix remaining linting issues that couldn't be auto-fixed.
          3. **Improve Test Coverage**: Add tests for files with < 80% coverage.
          4. **Remove Dead Code**: Review and remove identified unused code.
          5. **Security Review**: Address any security concerns identified above.
          
          ---
          
          *This optimization was performed automatically. All changes are production-safe and non-breaking.*
          EOF
          
      # Stage 8: Commit changes if any
      - name: Commit optimization changes
        id: commit
        if: steps.autofix.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add -A
          git commit -m "ðŸ¤– Auto-optimize: Apply safe fixes and improvements
          
          - Auto-fixed ESLint issues
          - Applied code formatting
          - Updated based on best practices
          
          All changes are safe and non-breaking.
          Generated by Self-Optimizing Workflow." || echo "No changes to commit"
          
          # Push changes
          git push || echo "Could not push changes"
          
          echo "changes_committed=true" >> $GITHUB_OUTPUT
          
      # Stage 9: Create inline PR comments for issues
      - name: Post inline PR comments
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const prNumber = context.issue.number;
            
            // Read ESLint report and create inline comments
            let eslintReport = [];
            try {
              eslintReport = JSON.parse(fs.readFileSync('eslint-report.json', 'utf8'));
            } catch (e) {
              console.log('No ESLint report found');
            }
            
            // Get PR files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const changedFiles = new Set(files.map(f => f.filename));
            
            // Create comments for unfixable issues in changed files
            for (const fileReport of eslintReport) {
              const relativePath = fileReport.filePath.replace(process.env.GITHUB_WORKSPACE + '/', '');
              
              // Only comment on files changed in this PR
              if (!changedFiles.has(relativePath)) continue;
              
              for (const message of fileReport.messages) {
                // Only comment on errors that couldn't be auto-fixed
                if (!message.fix && message.severity === 2) {
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      body: `âš ï¸ **${message.ruleId || 'ESLint'}**: ${message.message}\n\n` +
                            `**Severity**: ${message.severity === 2 ? 'Error' : 'Warning'}\n` +
                            `**Suggested Action**: ${message.suggestions?.[0]?.desc || 'Manual review required'}\n\n` +
                            `*This comment was automatically generated by the Self-Optimizing Workflow.*`,
                      path: relativePath,
                      line: message.line,
                      side: 'RIGHT'
                    });
                  } catch (e) {
                    console.log(`Could not create comment for ${relativePath}:${message.line} - ${e.message}`);
                  }
                }
              }
            }
            
            // Post summary comment
            let reportContent = '';
            try {
              reportContent = fs.readFileSync('optimization-report.md', 'utf8');
            } catch (e) {
              reportContent = '# Optimization Report\n\nReport generation failed.';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: reportContent
            });
            
            console.log('Posted optimization report to PR');
            
      # Stage 10: Upload artifacts
      - name: Upload analysis artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: optimization-reports
          path: |
            optimization-report.md
            eslint-report.json
            eslint-webapp-report.json
            ts-prune-report.json
            depcheck-report.json
            npm-audit.json
            coverage-report.md
            security-report.md
            unused-exports.txt
          retention-days: 30
          if-no-files-found: ignore
          
  # Generate test stubs for low coverage files
  generate-tests:
    name: Generate Missing Tests
    runs-on: ubuntu-latest
    needs: analyze-and-optimize
    if: needs.analyze-and-optimize.outputs.coverage_analyzed == 'true'
    timeout-minutes: 20
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref || github.ref }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Download coverage data
        uses: actions/download-artifact@v4
        with:
          name: optimization-reports
          path: ./reports
          
      - name: Generate test stubs
        run: |
          # Create a script to generate test stubs for uncovered files
          cat > generate-tests.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // Read coverage report
          let coverageData = {};
          try {
            coverageData = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
          } catch (e) {
            console.log('No coverage data found');
            process.exit(0);
          }
          
          // Find files with low coverage
          const lowCoverageFiles = Object.entries(coverageData)
            .filter(([file, data]) => {
              return file !== 'total' && 
                     data.lines.pct < 80 && 
                     !file.includes('.test.ts') &&
                     !file.includes('.spec.ts') &&
                     !file.includes('__tests__');
            })
            .map(([file]) => file);
          
          console.log(`Found ${lowCoverageFiles.length} files needing tests`);
          
          // Generate basic test stubs
          for (const file of lowCoverageFiles.slice(0, 5)) { // Limit to 5 files per run
            const testFile = file.replace('/src/', '/src/__tests__/').replace('.ts', '.test.ts');
            const testDir = path.dirname(testFile);
            
            // Create test directory if needed
            if (!fs.existsSync(testDir)) {
              fs.mkdirSync(testDir, { recursive: true });
            }
            
            // Skip if test already exists
            if (fs.existsSync(testFile)) continue;
            
            // Read source file to extract exports
            let sourceContent = '';
            try {
              sourceContent = fs.readFileSync(file, 'utf8');
            } catch (e) {
              continue;
            }
            
            // Extract function names (basic regex)
            const functionMatches = sourceContent.match(/export\s+(async\s+)?function\s+(\w+)/g) || [];
            const functions = functionMatches.map(m => m.match(/function\s+(\w+)/)?.[1]).filter(Boolean);
            
            // Extract class names
            const classMatches = sourceContent.match(/export\s+class\s+(\w+)/g) || [];
            const classes = classMatches.map(m => m.match(/class\s+(\w+)/)?.[1]).filter(Boolean);
            
            // Generate test stub
            const relativePath = path.relative(path.dirname(testFile), file).replace(/\\/g, '/').replace('.ts', '');
            
            let testContent = `import { ${[...functions, ...classes].join(', ')} } from '${relativePath}';\n\n`;
            testContent += `describe('${path.basename(file, '.ts')}', () => {\n`;
            
            // Add test stubs for functions
            for (const func of functions) {
              testContent += `  describe('${func}', () => {\n`;
              testContent += `    it('should be defined', () => {\n`;
              testContent += `      expect(${func}).toBeDefined();\n`;
              testContent += `    });\n`;
              testContent += `\n`;
              testContent += `    // TODO: Add more comprehensive tests\n`;
              testContent += `    it.todo('should handle valid inputs correctly');\n`;
              testContent += `    it.todo('should handle edge cases');\n`;
              testContent += `    it.todo('should handle errors appropriately');\n`;
              testContent += `  });\n\n`;
            }
            
            // Add test stubs for classes
            for (const cls of classes) {
              testContent += `  describe('${cls}', () => {\n`;
              testContent += `    it('should be defined', () => {\n`;
              testContent += `      expect(${cls}).toBeDefined();\n`;
              testContent += `    });\n`;
              testContent += `\n`;
              testContent += `    // TODO: Add more comprehensive tests\n`;
              testContent += `    it.todo('should instantiate correctly');\n`;
              testContent += `    it.todo('should have expected methods');\n`;
              testContent += `  });\n\n`;
            }
            
            testContent += `});\n`;
            
            // Write test file
            fs.writeFileSync(testFile, testContent);
            console.log(`Generated test stub: ${testFile}`);
          }
          EOF
          
          node generate-tests.js
          
      - name: Commit generated tests
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            
            git add -A
            git commit -m "ðŸ§ª Auto-generate: Add test stubs for low-coverage files
            
            Generated test stubs to improve coverage.
            TODO items added for comprehensive test implementation.
            
            Generated by Self-Optimizing Workflow."
            
            git push || echo "Could not push changes"
          fi
